import json

import bjontegaard as bd
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from compressai_trainer.utils.optimal import optimal_dataframe

sns.set_theme(
    # context="paper",
    style="whitegrid",
    font="Times New Roman",
    # font_scale=1,
)

# FULL_CSV generated by:
# poetry run compressai-plot --aim_repo=/path/to/aim/repo \
#   --query='"pcc-cls-only-pointnet" in run.model.name and run.dataset.train.meta.name == "ModelNet40" and run.hp.num_channels.g_a.pointwise == [3,64,64,64,128,1024]' \
#   --x='bpp_loss' --y='acc_top1' \
#   --out_csv=results/plot_rd/modelnet40_bpp_loss_full.csv \
#   --out_html=results/plot_rd/modelnet40_bpp_loss_full.html
#
# LITE_CSV generated by:
# poetry run compressai-plot --aim_repo=/path/to/aim/repo \
#   --query='"pcc-cls-only-pointnet" in run.model.name and run.dataset.train.meta.name == "ModelNet40" and run.hp.num_channels.g_a.pointwise == [3,8,8,16,16,32]' \
#   --x='bpp_loss' --y='acc_top1' \
#   --out_csv=results/plot_rd/modelnet40_bpp_loss_lite.csv \
#   --out_html=results/plot_rd/modelnet40_bpp_loss_lite.html
#
# AGGREGATE_NEW_TSV generated using:
# poetry run python scripts/eval_modelnet.py

FULL_CSV = "results/plot_rd/modelnet40_bpp_loss_full.csv"
LITE_CSV = "results/plot_rd/modelnet40_bpp_loss_lite.csv"
AGGREGATE_NEW_TSV = "results/tmc13_pointnet_001_aggregate_new.tsv"

DF_READ_OPTIONS = {"comment": "#", "skip_blank_lines": True}
OPTIMAL_METHOD = "convex"  # "none", "pareto", "convex"


def read_df_full() -> pd.DataFrame:
    df = pd.read_csv(FULL_CSV, **DF_READ_OPTIONS)
    df["acc_top1"] *= 100
    df["bit_loss"] = df["bpp_loss"]
    return df


def read_df_lite() -> pd.DataFrame:
    df = pd.read_csv(LITE_CSV, **DF_READ_OPTIONS)
    df["acc_top1"] *= 100
    df["bit_loss"] = df["bpp_loss"]
    return df


def read_df_input_compression() -> pd.DataFrame:
    df = pd.read_csv(AGGREGATE_NEW_TSV, **DF_READ_OPTIONS, sep="\t")
    df["acc_top1"] *= 100
    df["bit_loss"] = df["filesize_bits"]
    df["hp.num_points"] = df["num_points"]
    return df


def write_dfs_json(df_full, df_lite, df_icc):
    df_full = df_full.copy()
    df_lite = df_lite.copy()
    df_icc = df_icc.copy()

    x = "bit_loss"
    y = "acc_top1"

    df_full["model.name"] = df_full["hp.num_points"].apply(lambda n: f"full_points={n}")
    df_lite["model.name"] = df_lite["hp.num_points"].apply(lambda n: f"lite_points={n}")
    df_icc_optimal = optimal_dataframe(df_icc, x=x, y=y, method=OPTIMAL_METHOD)
    df_icc_optimal["model.name"] = "input-compression-tmc13"

    columns = ["model.name", x, y]
    df_all = pd.concat([df_full[columns], df_lite[columns], df_icc_optimal[columns]])
    df_all = optimal_dataframe(
        df_all, x=x, y=y, method=OPTIMAL_METHOD, groupby="model.name"
    )
    df_all[x] = df_all[x].round(3)
    df_all[y] = df_all[y].round(3)

    for model_name, df_curr in df_all.groupby("model.name"):
        df_curr = df_curr.drop(columns=["model.name"])
        results = df_curr.to_dict()
        results = {k: list(v.values()) for k, v in results.items()}
        out_dict = {
            "name": model_name,
            "results": results,
        }

        with open(f"results/plot_rd/json/{model_name}.json", "w") as f:
            json.dump(out_dict, f, indent=2)


def plot_df(
    df, by, ax, label_fmt, colors, x="bit_loss", y="acc_top1", df_reference=None
):
    if by is None:
        by = lambda _: True
    else:
        df = df.sort_values(by, ascending=False).reset_index(drop=True)

    for i, (value, df_curr) in enumerate(df.groupby(by, sort=False)):
        df_curr = optimal_dataframe(df_curr, x=x, y=y, method=OPTIMAL_METHOD)
        sns.lineplot(
            ax=ax,
            data=df_curr,
            x=x,
            y=y,
            label=label_fmt.format(value),
            color=colors[i],
        )

        if df_reference is None:
            continue

        # Compute BD-rate and BD-PSNR for the current curve.
        bd_rate = bd.bd_rate(
            rate_anchor=df_reference[x],
            dist_anchor=df_reference[y],
            rate_test=df_curr[x],
            dist_test=df_curr[y],
            method="akima",
            require_matching_points=False,
        )

        bd_dist = bd.bd_psnr(
            rate_anchor=df_reference[x],
            dist_anchor=df_reference[y],
            rate_test=df_curr[x],
            dist_test=df_curr[y],
            method="akima",
            require_matching_points=False,
        )

        print(f"{label_fmt.format(value):<40} & {bd_rate:6.1f} & {bd_dist:6.1f}dB")


def main():
    dataset = "ModelNet40"

    colors = {
        "baseline_with_transform": "#999999",
        "baseline_no_transform": "#CCCCCC",
        "full": [
            "#2C942B",
        ],
        "lite": [
            "#4EB44E",
            "#4EB4A3",
            "#4E9BB4",
            "#4E4EB4",
            "#9B4EB4",
            "#B44E9B",
            "#B44E4E",
            "#B47A4E",
            "#B4B44E",
        ],
        "input_compression": [
            "#DDA451",
        ],
        # "#73D539",  # lime green
        # "#0354CE",  # cobalt blue
        # "#A34ECF",  # neon purple!
    }

    fig, ax = plt.subplots()

    ax.set(
        xlabel="Rate (bits)",
        ylabel="Top-1 Accuracy (%)",
        # xscale="log",
        # xlim=[10, 10000],
        xlim=[0, 600],
        ylim=[0, 100],
    )

    # ModelNet40 baselines
    if dataset == "ModelNet40":
        _, x_max = ax.get_xlim()
        ax.plot(
            [0, x_max],
            [89.2, 89.2],
            label="PointNet (with transforms) [official] [89.2%]",
            color=colors["baseline_with_transform"],
            linestyle="--",
        )
        ax.plot(
            [0, x_max],
            [87.1, 87.1],
            label="PointNet (no transforms) [official] [87.1%]",
            color=colors["baseline_no_transform"],
            linestyle="--",
        )

    df_full = read_df_full()
    df_lite = read_df_lite()
    df_icc = read_df_input_compression()

    df_reference = df_full[df_full["hp.num_points"] == 1024]
    df_reference = optimal_dataframe(
        df_reference, x="bit_loss", y="acc_top1", method=OPTIMAL_METHOD
    )

    write_dfs_json(df_full, df_lite, df_icc)

    plot_df(
        df_full,
        by="hp.num_points",
        ax=ax,
        label_fmt="Proposed codec [full, P={}]",
        # label_fmt="PointNet (no transforms) based full codec [P={}]",
        colors=colors["full"],
        df_reference=df_reference,
    )

    plot_df(
        df_lite,
        by="hp.num_points",
        ax=ax,
        label_fmt="Proposed codec [lite, P={}]",
        # label_fmt="PointNet (no transforms) based lite codec [P={}]",
        colors=colors["lite"],
        df_reference=df_reference,
    )

    icc_aggregate_only = True

    if icc_aggregate_only:
        plot_df(
            df_icc,
            by=None,
            ax=ax,
            label_fmt="Input-compression codec [tmc13, P=*]",
            # label_fmt="PointNet (no transforms) input-compression codec [tmc13, P=*]",
            colors=colors["input_compression"],
            df_reference=df_reference,
        )
    else:
        plot_df(
            df_icc,
            by="hp.num_points",
            ax=ax,
            label_fmt="Input-compression codec [tmc13, P={}]",
            # label_fmt="PointNet (no transforms) input-compression codec [tmc13, P={}]",
            # colors=colors["input_compression"],
            colors=colors["lite"],  # use same colors as lite codec
            df_reference=df_reference,
        )

    ax.legend(fontsize="small", loc="lower right")

    fig.savefig(f"results/plot_rd/rate_accuracy_{dataset.lower()}.pdf")
    fig.savefig(f"results/plot_rd/rate_accuracy_{dataset.lower()}.png", dpi=300)
    plt.show()


if __name__ == "__main__":
    main()
